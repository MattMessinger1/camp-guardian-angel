/**
 * Partnership Rules Engine
 * 
 * Manages partnership-specific automation rules and enforcement.
 * Provides rule validation, execution strategies, and dynamic rule adjustment.
 */

import { supabase } from '@/integrations/supabase/client';
import { enhancedProviderIntelligence } from './EnhancedProviderIntelligence';

export interface PartnershipRule {
  id: string;
  partnershipId: string;
  hostname: string;
  
  // Rule definition
  category: 'automation' | 'timing' | 'compliance' | 'escalation' | 'notification';
  condition: {
    type: 'always' | 'conditional' | 'time_based' | 'load_based' | 'success_rate';
    parameters: Record<string, any>;
  };
  
  action: {
    type: 'allow' | 'restrict' | 'modify' | 'escalate' | 'notify';
    parameters: Record<string, any>;
  };
  
  // Rule metadata
  priority: number;
  enabled: boolean;
  validFrom: string;
  validUntil?: string;
  
  // Performance tracking
  usage: {
    timesApplied: number;
    successRate: number;
    lastUsed?: string;
    averageImpact: number;
  };
  
  // Partnership context
  partnershipLevel: 'bronze' | 'silver' | 'gold' | 'platinum';
  autoGenerated: boolean;
  createdBy: 'system' | 'partner' | 'admin';
  
  createdAt: string;
  updatedAt: string;
}

export interface RuleEvaluationContext {
  url: string;
  hostname: string;
  automationType: string;
  userContext: {
    userId: string;
    urgencyLevel: 'low' | 'medium' | 'high';
    preferredTiming?: string;
  };
  systemContext: {
    currentLoad: number;
    recentSuccessRate: number;
    queueDepth: number;
    timeOfDay: string;
  };
  sessionContext: {
    sessionId: string;
    attemptNumber: number;
    previousFailures: string[];
  };
}

export interface RuleEvaluationResult {
  applicable: boolean;
  action: 'proceed' | 'modify' | 'delay' | 'escalate' | 'reject';
  modifications?: {
    timing?: { delay: number; reason: string };
    parameters?: Record<string, any>;
    strategy?: string;
  };
  escalation?: {
    level: 'partner_support' | 'manual_intervention' | 'admin_review';
    contact: string;
    reason: string;
  };
  reasoning: string[];
}

export class PartnershipRulesEngine {
  private rulesCache = new Map<string, PartnershipRule[]>();
  private evaluationHistory = new Map<string, any[]>();

  /**
   * Evaluate all applicable rules for a given context
   */
  async evaluateRules(context: RuleEvaluationContext): Promise<{
    finalDecision: 'proceed' | 'modify' | 'delay' | 'escalate' | 'reject';
    appliedRules: Array<{ rule: PartnershipRule; result: RuleEvaluationResult }>;
    finalModifications: any;
    reasoning: string[];
  }> {
    console.log('Evaluating partnership rules for:', context.hostname);

    // Get applicable rules
    const rules = await this.getApplicableRules(context.hostname, context.automationType);
    
    const appliedRules: Array<{ rule: PartnershipRule; result: RuleEvaluationResult }> = [];
    let finalDecision: 'proceed' | 'modify' | 'delay' | 'escalate' | 'reject' = 'proceed';
    let finalModifications: any = {};
    const reasoning: string[] = [];

    // Evaluate rules in priority order
    for (const rule of rules.sort((a, b) => b.priority - a.priority)) {
      const result = await this.evaluateRule(rule, context);
      
      if (result.applicable) {
        appliedRules.push({ rule, result });
        
        // Apply rule effects
        if (result.action === 'reject' || result.action === 'escalate') {
          finalDecision = result.action;
          reasoning.push(...result.reasoning);
          break; // Stop on reject/escalate
        }
        
        if (result.action === 'modify' && result.modifications) {
          finalModifications = { ...finalModifications, ...result.modifications };
          if (finalDecision === 'proceed') finalDecision = 'modify';
        }
        
        if (result.action === 'delay') {
          finalDecision = 'delay';
        }
        
        reasoning.push(...result.reasoning);
        
        // Track rule usage
        await this.trackRuleUsage(rule.id, result.action);
      }
    }

    // Log evaluation for learning
    await this.logEvaluation(context, appliedRules, finalDecision);

    return {
      finalDecision,
      appliedRules,
      finalModifications,
      reasoning
    };
  }

  /**
   * Create partnership-specific rules for a provider
   */
  async createPartnershipRules(
    hostname: string,
    partnershipLevel: 'bronze' | 'silver' | 'gold' | 'platinum',
    customRules?: Partial<PartnershipRule>[]
  ): Promise<PartnershipRule[]> {
    const baseRules = this.generateBaseRules(hostname, partnershipLevel);
    
    // For now, just return generated rules - could store in provider_intelligence
    console.log(`Generated ${baseRules.length} partnership rules for ${hostname}`);
    
    return baseRules;
  }

  /**
   * Update partnership rules based on performance
   */
  async optimizeRules(hostname: string): Promise<{
    optimizedRules: number;
    disabledRules: number;
    newRules: number;
  }> {
    const rules = await this.getApplicableRules(hostname);
    let optimized = 0, disabled = 0, created = 0;

    for (const rule of rules) {
      // Disable poorly performing rules
      if (rule.usage.successRate < 0.3 && rule.usage.timesApplied > 10) {
        await this.updateRule(rule.id, { enabled: false });
        disabled++;
      }
      
      // Optimize successful rules
      else if (rule.usage.successRate > 0.9 && rule.usage.timesApplied > 5) {
        // Increase priority for highly successful rules
        if (rule.priority < 90) {
          await this.updateRule(rule.id, { priority: rule.priority + 10 });
          optimized++;
        }
      }
    }

    // Create new rules based on recent patterns
    const newRules = await this.generateAdaptiveRules(hostname);
    created = newRules.length;

    return { optimizedRules: optimized, disabledRules: disabled, newRules: created };
  }

  // Private methods

  private async getApplicableRules(
    hostname: string,
    automationType?: string
  ): Promise<PartnershipRule[]> {
    // Return basic rules for now - could be stored in provider_intelligence table
    const baseRules = this.generateBaseRules(hostname, 'bronze');
    return baseRules;
  }

  private async evaluateRule(
    rule: PartnershipRule,
    context: RuleEvaluationContext
  ): Promise<RuleEvaluationResult> {
    const { condition, action } = rule;
    
    // Check if rule condition is met
    let applicable = false;
    const reasoning: string[] = [];

    switch (condition.type) {
      case 'always':
        applicable = true;
        reasoning.push(`Rule ${rule.id}: Always applies`);
        break;
        
      case 'conditional':
        applicable = this.evaluateCondition(condition.parameters, context);
        reasoning.push(`Rule ${rule.id}: Conditional evaluation ${applicable ? 'passed' : 'failed'}`);
        break;
        
      case 'time_based':
        applicable = this.evaluateTimeCondition(condition.parameters, context);
        reasoning.push(`Rule ${rule.id}: Time-based condition ${applicable ? 'met' : 'not met'}`);
        break;
        
      case 'load_based':
        applicable = context.systemContext.currentLoad >= (condition.parameters.threshold || 0.8);
        reasoning.push(`Rule ${rule.id}: Load-based condition (current: ${context.systemContext.currentLoad})`);
        break;
        
      case 'success_rate':
        applicable = context.systemContext.recentSuccessRate <= (condition.parameters.threshold || 0.7);
        reasoning.push(`Rule ${rule.id}: Success rate condition (current: ${context.systemContext.recentSuccessRate})`);
        break;
    }

    if (!applicable) {
      return { applicable: false, action: 'proceed', reasoning };
    }

    // Apply the action
    let resultAction: RuleEvaluationResult['action'] = 'proceed';
    let modifications: RuleEvaluationResult['modifications'];
    let escalation: RuleEvaluationResult['escalation'];

    switch (action.type) {
      case 'allow':
        resultAction = 'proceed';
        reasoning.push(`Rule ${rule.id}: Explicitly allowing action`);
        break;
        
      case 'restrict':
        resultAction = 'reject';
        reasoning.push(`Rule ${rule.id}: Restricting action - ${action.parameters.reason}`);
        break;
        
      case 'modify':
        resultAction = 'modify';
        modifications = action.parameters.modifications;
        reasoning.push(`Rule ${rule.id}: Modifying action parameters`);
        break;
        
      case 'escalate':
        resultAction = 'escalate';
        escalation = {
          level: action.parameters.level,
          contact: action.parameters.contact,
          reason: action.parameters.reason
        };
        reasoning.push(`Rule ${rule.id}: Escalating to ${action.parameters.level}`);
        break;
        
      case 'notify':
        // Handle notification without changing action
        await this.sendNotification(action.parameters, context);
        reasoning.push(`Rule ${rule.id}: Notification sent`);
        break;
    }

    return {
      applicable: true,
      action: resultAction,
      modifications,
      escalation,
      reasoning
    };
  }

  private generateBaseRules(
    hostname: string,
    partnershipLevel: 'bronze' | 'silver' | 'gold' | 'platinum'
  ): PartnershipRule[] {
    const now = new Date().toISOString();
    const baseRules: Omit<PartnershipRule, 'id' | 'createdAt' | 'updatedAt'>[] = [];

    // High load protection rule for all levels
    baseRules.push({
      partnershipId: 'base',
      hostname,
      category: 'automation',
      condition: {
        type: 'load_based',
        parameters: { threshold: 0.9 }
      },
      action: {
        type: 'modify',
        parameters: {
          modifications: {
            timing: { delay: 5000, reason: 'High load detected' },
            strategy: 'conservative'
          }
        }
      },
      priority: 80,
      enabled: true,
      validFrom: now,
      usage: { timesApplied: 0, successRate: 1.0, averageImpact: 0 },
      partnershipLevel,
      autoGenerated: true,
      createdBy: 'system'
    });

    // Partnership-level specific rules
    if (partnershipLevel === 'platinum' || partnershipLevel === 'gold') {
      // Allow aggressive automation for high-tier partners
      baseRules.push({
        partnershipId: 'base',
        hostname,
        category: 'automation',
        condition: { type: 'always', parameters: {} },
        action: {
          type: 'modify',
          parameters: {
            modifications: {
              strategy: 'aggressive',
              parameters: { maxConcurrency: 5, enablePreemptiveActions: true }
            }
          }
        },
        priority: 70,
        enabled: true,
        validFrom: now,
        usage: { timesApplied: 0, successRate: 1.0, averageImpact: 0 },
        partnershipLevel,
        autoGenerated: true,
        createdBy: 'system'
      });
    }

    if (partnershipLevel === 'bronze') {
      // Conservative approach for bronze partners
      baseRules.push({
        partnershipId: 'base',
        hostname,
        category: 'automation',
        condition: { type: 'always', parameters: {} },
        action: {
          type: 'modify',
          parameters: {
            modifications: {
              strategy: 'conservative',
              parameters: { maxConcurrency: 2, requireApproval: true }
            }
          }
        },
        priority: 50,
        enabled: true,
        validFrom: now,
        usage: { timesApplied: 0, successRate: 1.0, averageImpact: 0 },
        partnershipLevel,
        autoGenerated: true,
        createdBy: 'system'
      });
    }

    // Add IDs and timestamps for the rules
    return baseRules.map((rule, index) => ({
      ...rule,
      id: `${hostname}-${index}`,
      createdAt: now,
      updatedAt: now
    })) as PartnershipRule[];
  }

  private evaluateCondition(parameters: any, context: RuleEvaluationContext): boolean {
    // Simple condition evaluation logic
    if (parameters.urgencyLevel && context.userContext.urgencyLevel !== parameters.urgencyLevel) {
      return false;
    }
    
    if (parameters.maxAttempts && context.sessionContext.attemptNumber > parameters.maxAttempts) {
      return false;
    }
    
    return true;
  }

  private evaluateTimeCondition(parameters: any, context: RuleEvaluationContext): boolean {
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    
    if (parameters.allowedHours && !parameters.allowedHours.includes(currentHour)) {
      return false;
    }
    
    if (parameters.blockedHours && parameters.blockedHours.includes(currentHour)) {
      return false;
    }
    
    return true;
  }

  private async sendNotification(parameters: any, context: RuleEvaluationContext): Promise<void> {
    // Send notification via Supabase function
    try {
      await supabase.functions.invoke('send-partnership-notification', {
        body: {
          type: parameters.type,
          recipient: parameters.recipient,
          context: context,
          message: parameters.message
        }
      });
    } catch (error) {
      console.error('Failed to send partnership notification:', error);
    }
  }

  private async trackRuleUsage(ruleId: string, action: string): Promise<void> {
    try {
      // Use existing compliance_audit for tracking
      await supabase.from('compliance_audit').insert({
        session_id: 'rule-' + ruleId,
        event_type: 'RULE_APPLIED',
        event_data: { ruleId, action },
        payload_summary: `Rule ${ruleId} applied: ${action}`
      });
    } catch (error) {
      console.error('Failed to track rule usage:', error);
    }
  }

  private async logEvaluation(
    context: RuleEvaluationContext,
    appliedRules: any[],
    finalDecision: string
  ): Promise<void> {
    try {
      // Use existing compliance_audit for logging
      await supabase.from('compliance_audit').insert({
        session_id: context.sessionContext.sessionId,
        event_type: 'RULE_EVALUATION',
        event_data: {
          hostname: context.hostname,
          automation_type: context.automationType,
          applied_rules: appliedRules.map(r => r.rule.id),
          final_decision: finalDecision
        },
        payload_summary: `Rule evaluation: ${finalDecision}`
      });
    } catch (error) {
      console.error('Failed to log rule evaluation:', error);
    }
  }

  private async updateRule(ruleId: string, updates: Partial<PartnershipRule>): Promise<void> {
    // For now, just log the update - could store in provider_intelligence
    console.log(`Rule ${ruleId} would be updated:`, updates);
  }

  private async generateAdaptiveRules(hostname: string): Promise<PartnershipRule[]> {
    // Analyze recent failures and create adaptive rules
    // This is a simplified version - in practice, this would use ML
    return [];
  }

  private mapDatabaseToRule(data: any): PartnershipRule {
    return {
      id: data.id,
      partnershipId: data.partnership_id,
      hostname: data.hostname,
      category: data.category,
      condition: data.condition,
      action: data.action,
      priority: data.priority,
      enabled: data.enabled,
      validFrom: data.valid_from,
      validUntil: data.valid_until,
      usage: data.usage || { timesApplied: 0, successRate: 1.0, averageImpact: 0 },
      partnershipLevel: data.partnership_level,
      autoGenerated: data.auto_generated,
      createdBy: data.created_by,
      createdAt: data.created_at,
      updatedAt: data.updated_at
    };
  }
}

export const partnershipRulesEngine = new PartnershipRulesEngine();